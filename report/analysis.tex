\section{Problem analysis}

\subsection{Analysis of automata generated by approximate kleenex}

Visualization.

\subsection{Improving kleenex}

% TODO: write properly

The result of the $k$-fold rewrite of a core Kleenex program, as described in
Troelsen's thesis, is proved to be possible to execute in time $O(mnk)$ by
determinization to an SST, where $n = |t|$ is the size of the input string and
$m$ is the size of the transition relation of the corresponding NFST. This is
proved by arguing that the growth of the number of transitions in the transucer
is in the order $O(mk)$, since the transformation adds $k$ new transitions to
the transducer for each existing transition and at most a constant number of
additional transitions for each of these new transitions, depending on the
error metric.  This utilizes the results of Theorem 1 and Corollary 1 in the
POPL paper.

Theorem 2 from the POPL paper states that for an oracle machine of size $m$,
i.e. the size of the transition relation, there is a (semantically equivalent)
SST with $O(2^{m \log m})$ states.

A corollary to this is that for a core Kleenex program with a corresponding
transducer of size $m$, allowing approximate matches with up to $k$ errors,
there is an SST with $(O^{mk \log mk})$ states. Thus, the number of states in
the SST resulting from the rewriting of core Kleenex and following
determinization of the NFST, is exponential in $k$.


% Counters, implemented as optimization in the implementation vs. updating the
% automata models.

\subsubsection{Tagged automata}

In his bachelor's thesis~\cite{enevoldsen2015pattern}, Sune Enevoldsen uses the
concept of a tagged automaton, based on work by Ville
Laurikari~\cite{laurikari2000nfas, laurikari2001efficient} and inspired by
Levenshtein automata~\cite{schulz2002fast}, to do approximate regular string
matching.

A nondeterministic automaton with tagged transitions, or a tagged NFA, is an
NFA extended with a set of tags which may be set or modified on each transition
in the transition relation. The idea is to use these tags as counters which
keep track of the allowed number of errors, e.g.  insertions, deletion, and
substitutions. A formal definition follows:

% Thus, the tagged automata for a given regular expression $RE$ will accept the
% strings in $\mathcal{L}(RE)$ as well as any string that is within a certain
% error distance of a string in $\mathcal{L}(RE)$.

\begin{definition}[NTA] 
  A \emph{nondeterministic tagged automaton} (NTA) is a structure
  $(\Sigma, Q, q^s, F, T, t_0, \Delta)$, where $\Sigma$ is a finite alphabet,
  $Q$ is a finite set of states, $q^s$ is the initial state, and
  $F \subseteq Q$ is the set of final states. $T$ is a set of possible tag
  values, $t_0$ is the initial tag value and $\Delta$ is the transition
  relation
  \[
    \Delta \subseteq Q \times T \times \Sigma[\epsilon] \times Q \times T \;.
  \]
\end{definition}

The transition relation can also be described in terms of functions on tag
values, i.e. functions that take a tag value as argument and returns a possibly
updated set of tags. Such a function may ignore the tag, i.e. just return a
singleton set of the given unchanged tag, it may set a new a new tag
independent of the current tag value, or it may set a tag value depending on
the current value.

To use this automaton for approximate regular string matching using the
Levenshtein distance metric, we can set $T = \mathbb{N}^3$ (including zero) and
$t_0 = (0,0,0)$. Thus, when entering a subexpression which allows a specified
number of substitutions, insertions, and deletions, the ingoing transition can
set the tag to the allowed errors.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
