\section{Problem analysis}

\subsection{Analysis of automata generated by approximate kleenex}

Visualization.

\subsection{Improving Kleenex}
% TODO: write properly

The result of the $k$-fold rewrite of a core Kleenex program, as described in
Troelsen's thesis~\cite{troelsen2016approximate}, is proved to be possible to
execute in time $\mathcal{O}(mnk)$ by determinization to an SST, where $n$ is
the size of the input string and $m$ is the size of the transition relation of
the corresponding NFST. This is proved by arguing that the growth of the number
of transitions in the transducer is in the order $\mathcal{O}(mk)$ (for $k>0$),
since the transformation adds $k$ new transitions to the transducer for each
existing transition and at most a constant number of additional transitions for
each of these new transitions, depending on the error metric. The
aforementioned time bound then follows from the result
in~\cite{grathwohl2016kleenex} that the SST can be implemented to execute in
time $\mathcal{O}(mn)$.

%This utilizes the results of Theorem 1 and Corollary 1 in the POPL paper.

Grathwohl et al.~\cite{grathwohl2016kleenex} also prove that for an oracle
machine of size $m$, i.e. an NFST with $m$ transitions, there is a semantically
equivalent SST with $\mathcal{O}(2^{m \log m})$ states. A corollary to this is
that for a core Kleenex program with a corresponding transducer of size $m$,
allowing approximate matches with up to $k$ errors, there is an SST with
$\mathcal{O}(2^{mk \log mk})$ states. Thus, the number of states in the SST
resulting from the rewriting of core Kleenex and following determinization of
the NFST, is exponential in $k$.

This seems to suggest a potential cause of the increased compilation times when
using approximate matching in Kleenex and the very large output programs that
it generates. Thus, one may be interested in exploring ways to avoid the
increase in size of the NFST.

% Theorem 2 from the POPL paper states that for an oracle machine of size $m$,
% i.e. the size of the transition relation, there is a (semantically equivalent)
% SST with $O(2^{m \log m})$ states.

% Counters, implemented as optimization in the implementation vs. updating the
% automata models.

\subsubsection{Tagged automata}

In his bachelor's thesis~\cite{enevoldsen2015pattern}, Sune Enevoldsen uses the
concept of a tagged automaton, based on work by Ville
Laurikari~\cite{laurikari2000nfas, laurikari2001efficient} and inspired by
Levenshtein automata~\cite{schulz2002fast}, to do approximate regular string
matching.

A nondeterministic automaton with tagged transitions, or a tagged NFA, is an
NFA extended with a set of tags which may be set or modified on each transition
in the transition relation. The idea is to use these tags as counters which
keep track of the allowed number of errors, e.g.  insertions, deletion, and
substitutions. A formal definition follows:

% Thus, the tagged automata for a given regular expression $RE$ will accept the
% strings in $\mathcal{L}(RE)$ as well as any string that is within a certain
% error distance of a string in $\mathcal{L}(RE)$.

\begin{definition}[NTA] 
  A \emph{nondeterministic tagged automaton} (NTA) is a structure
  $(\Sigma, Q, q^s, F, T, t_0, \Delta)$, where $\Sigma$ is a finite alphabet,
  $Q$ is a finite set of states, $q^s$ is the initial state, and
  $F \subseteq Q$ is the set of final states. $T$ is a set of possible tag
  values, $t_0$ is the initial tag value and $\Delta$ is the transition
  relation
  \[
    \Delta \subseteq Q \times T \times \Sigma[\epsilon] \times Q \times T \;.
  \]
\end{definition}

The transition relation can also be described in terms of functions on tag
values, i.e. functions that take a tag value as argument and returns a possibly
updated set of tags. For the purpose of approximate matching and as in
Enevoldsen's thesis, this function will always return just a singleton set or
the empty set. Such a tag function may ignore the tag, i.e. just return a
singleton set of the given unchanged tag, it may set a new a new tag
independent of the current tag value, or it may set a tag value depending on
the current value.

To use this automaton for approximate regular string matching using the
Levenshtein distance metric, we can set $T = \mathbb{N}^3$ (including zero) and
$t_0 = (0,0,0)$. Thus, when entering a subexpression which allows a specified
number of substitutions, insertions, and deletions, the ingoing transition can
set the tag to the allowed errors.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
